from datetime import datetime
from Py3dsMax import mxs

_datastack = []

class DataTracker:
	def __init__( self, title ):
		self.flush()
		self.title			= title
		self.init_time 		= datetime.now()
		self.init_memory	= mxs.heapfree
		
	def flush( self ):
		# flush out memory
		mxs.gc()
		mxs.gc()
	
	def report( self ):
		report = [ self.title ]
		report.append( "------------------------------------------------" )
		
		currtime	= datetime.now()
		currmem		= mxs.heapfree
			
		# call twice to clear
		self.flush()
			
		currmem_postgc	= mxs.heapfree
		
		report.append( "elapsed time: %s" % (currtime - self.init_time) )
		report.append( '' )
		report.append( "starting memory: %i" % self.init_memory )
		report.append( "ending memory (pre-gc): %i" % currmem )
		report.append( "memory lost (pre-gc): %i" % (self.init_memory - currmem) )
		report.append( "" )
		report.append( "ending memory (post-gc): %i" % currmem_postgc )
		report.append( "memory lost (post-gc): %i" % (self.init_memory - currmem_postgc) )
		report.append( '' )
		
		return "\n".join( report )

# push a root tracker on to compare against the initial memory and time settings
_stack = []

def popFrame():
	global _stack
	if ( len( _stack ) > 1 ):
		tracker = _stack[-1]
		_stack 	= _stack[:-1]
	else:
		tracker = _stack[0]
	
	return tracker

def pushFrame( title ):
	tracker = DataTracker( title )
	_stack.append( tracker )
	return tracker

def run( title, method ):
	# reset the memory, call the method, and then generate a report
	pushFrame( title )
	method()
	tracker = popFrame()
	
	return tracker.report()

def report():
	return _stack[-1].report()

pushFrame( 'Initial Memory' )
	